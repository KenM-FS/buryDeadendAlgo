# buryDeadendAlgo
This algorithm buries dead ends in lattice world

格子世界において袋小路を埋めるアルゴリズム

## 背景
大学の講義で鬼ごっこをするエージェントを作成する課題があった．逃げる側(追いかける側は「鬼」だけど逃げる側の名前ってなんだろう)のエージェントを作る際にそれなりに有用だと感じるアルゴリズムを考えたのだが，返却されたレポートにそのアルゴリズムの解説がわからないと書かれていて悔しかったのでこの場でリベンジする．

## 前提知識
詳しくは[講義ページ](https://www.fun.ac.jp/~osawa/course/DCS/lab/1/index.html "DCS Labolatory 1")を見ていただくとして，鬼ごっこのルールや用語について軽く解説する．この鬼ごっこは正確には二人追跡ゲーム(2 player pursuit game)と呼ばれ，鬼は捕食者(predator)，逃げる側は獲物(prey)と呼ばれる．捕食者と獲物が2次元の格子世界上で追う・逃げるを行う．講義では8x8の格子世界が用いられた．ターン性でゲームが進行し，各エージェントは上，下，右，左の4つから行動を選択する．格子世界には障害物が存在し，それを認識して行動を選択することが求められる．何もない格子(グリッド)は自由格子(free grid)と呼ばれる．

出力や図で用いる記号表現は以下のようである
- 獲物: "*"
- 捕食者: "@"
- 障害物: "#"
- 自由格子: "."

## アルゴリズムの概要
獲物が逃げる際，袋小路に逃げ込むのは一番避けたい事である．このアルゴリズムは袋小路となっている部分を埋める(自由格子を障害物に変換する)処理を行う．この処理によって獲物は袋小路に入りこまなくなる．埋めるのは障害物によってのみ形成される袋小路のみであり，格子世界の端(境界)は袋小路を形成する要素として判断しない．

**獲物の視点で埋められているだけで，実際のゲームの格子世界・捕食者が持つ格子世界の情報に変化を与えるわけではないことに注意．**

## 具体的な処理
自由格子であるグリッドの1つに注目してそのグリッドを条件によって埋める処理を，格子世界全体に適用させることで袋小路を埋める処理を実現している．あるグリッドに対する上下左右のグリッドを4方向近傍のグリッドと呼ぶことにする．

4方向近傍のグリッドのうち，3つ以上が障害物であれば明らかにそのグリッドは袋小路であり，そこは埋めても問題ないので埋める処理を行う．この条件に当てはまるような状態は5パターン存在する．

![3or4obstacles](./images/3or4obstacles.png "障害物が3つ以上のパターン")

4方向近傍のグリッドのうち，2つが障害物であるとき，そのグリッドを埋めることで通がふさがらない場合のみグリッドを埋める処理を行う．2つの障害物が注目しているグリッドの上下もしくは左右に存在している場合，そのグリッドを埋めることで通がふさがるのは明らかである．それ以外の場合，例えば上と右が障害物の時，左下が障害物であったらそのグリッドを埋めることで道がふさがってしまう．これは右と下が障害物の時に左上，下と左が障害物の時右上，左と上が障害物の時右下が障害物のとき同じことが言える．よって以上を満たさない以下の画像のパターンのとき埋める処理を行う．

![2obstacles](./images/2obstacles.png "障害物が2つのパターン")

以上のような処理を格子世界の全グリッドに適用させ，もしあるグリッドが埋められたならば，その変更を伝播させていくためにそのグリッドの4方向近傍の全てのグリッドに同じ処理を適用させる．

## プログラムの説明
このプログラムはC言語にて作成されている．普通にコンパイルして実行すれば動く(そこらへん詳しくない．筆者はgcc使った)．

コマンドライン引数でファイル名を変更することで任意の格子世界にこのアルゴリズムを適用させることができる．初期設定は`battlefield.dat`である．たとえば`battlefield1.dat`に適用させたい場合，
```
$ ./buryDeadend.out battlefield1.dat
```
で実現できる．格子世界のファイルは64行で各行に1つの値，自由格子は`0`，障害物は`-1`，捕食者は`1`，獲物`10`で表せられることに注意する．これを満たさない場合エラーが返される．エラー処理はちゃんとやったつもりだけど自信はない．プログラム内の`WORLD_SIZE`を変更することで(縦横が同じであれば)格子世界の大きさが違っても機能するはず．

このプログラムを実行すると以下のように，もともとの格子世界と袋小路を埋めた格子世界をそれぞれ出力する．

![Work Image](./images/workImage.png "Work Image")

## 特徴
このアルゴリズムが優れていると考える点をいくつか紹介する
### 獲物が閉じ込められることがない
以下の画像のような格子世界であった場合，内側はすべて埋められる．

![wontLocked1](./images/wontLocked1.png "内側はすべて埋められる")

しかし，内側に獲物が存在する場合，袋小路から脱出する通のみ残してくれる．

![wontLocked2](./images/wontLocked2.png "脱出経路が確保されている")

この状態で獲物が選択できる行動は1つで，移動した後は後ろが埋められて戻れないため必ず袋小路の外に出ることができる．
### 袋小路を完全に埋めないパターンがある
袋小路の中に障害物があった場合，それを用いて逃げることができる．以下は極端な例であるが，袋小路の中で障害物を用いて逃走するための最適な通のみを残してくれる．

![leavePath](./images/leavePath.png "道ができる")

この例でなくても，障害物同士の隙間やL字の障害物周りについても同じような処理がされるので，通り道がふさがることはない(はず)．

## このアルゴリズムの限界・欠点
### どこまでを袋小路として定義するか
このアルゴリズムは格子世界の境界(端)と障害物で構成された袋小路を埋めることができない．境界を含めるようにすると，格子世界そのものが袋小路であるから期待される処理を実現するためにさらなる場合分けを追加する必要があり，動作も不安定になる可能性があると考える．

格子世界に障害物がある程度存在することを前提にすると，[特徴](#特徴)で説明したように障害物と障害物の間に通が確保されるので単純に境界を袋小路を構成する要素として追加してもうまく行くかもしれない．
### 処理が純粋な場合分け
処理が[具体的な処理](#具体的な処理)で説明したパターンに当てはまるかどうかを場合分けのような形で行っているため，コードの可読性がなく，より効率的で綺麗なものが存在するはずである．
## 本題とは関係ないけどアドバイス
例外処理をちゃんとやりましょう．基本的にはvoid関数は使わず，なにかしらのintを返すことでエラーの特定を容易にするだけでなく，本番で例外が発生した際に私のようにエラー落ちで失格にならなくて済むかもしれない．講義で配布されるゲームを進行する`pursuit.c`が非常に参考になるのでエージェントを作成する前に一目通しておくといいことがあるはず．

たいていのエラーは配列の参照で発生する．`buryDeadend.c`の42行目にある以下のような関数
```c
int get_index(int i, int j){
  if(i<0 || i>WORLD_SIZE || j<0 || j>WORLD_SIZE) return WORLD_SIZE*WORLD_SIZE;
  return WORLD_SIZE*i + j;
}
```
これを介して配列参照を行うことで，配列参照によるエラーをなくすことができる．例えば以下のように値の参照を行う．
```c
// listは配列へのポインタ
*(list+get_index(i,j))
```

参考までに，筆者はこのアルゴリズムを用いて，捕食者からの実際の距離と直線距離の差が一番大きくなるグリッドを目指して逃げるみたいな戦略を考えた．結局エラー落ちで結果が出なかったのでこれが有用かどうかは不明．エラー落ちでトーナメントは失格だったが，レポートは納得のいく評価をいただいたので同じ境遇になっても絶望せずに次の課題も頑張りましょう．

## 最後に
このアイディアを使ってもらうのは願ったりかなったりだが，丸々コピーするのはやめましょう(私も怒られるので)．使用報告や質問や意見をくれるととても喜びます．改善点(特にプログラム)とかは是非欲しい．

まだ解説がわかりにくい気がする．特に[具体的な処理](#具体的な処理)の部分．全パターンを列挙する力技を使えば確実だけどもっと効率的な解説を求めたい．ここがわかりづらいとかあれば遠慮なくお願いします．